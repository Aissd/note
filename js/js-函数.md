### 函数提升

```
hd(); // houdunren.com 函数会提升

function hd() {
	console.log('houdunren.com');
}

var hd = function() {
	console.log('后盾人');
}
```

> 箭头函数没有变量提升

### 函数是对象

```
hd instanceof Object; // true
```

### 立即执行函数 - 立即执行，无需调用

```
;(function(window) {
	// 私有作用域，外界访问不到
	function hd() {
		console.log('hd');
	}
	function cmd() {
		console.log('cmd');
	}
	window.temp = { hd, cmd }; // 对外暴露
})(window);
```

### 当函数执行时，会开辟出一块新的内存地址，多次执行就开辟多个；

### 箭头函数

* 1）不适合在事件处理的匿名函数（this问题）
* 2）不适合在递归中使用（没有函数名）
* 3）箭头函数中的this指向的是上下文（即父级作用域中的this）

### arguments不是数组类型 

```
typeof arguments; // object
```

### call和apply的区别是什么？哪个性能更好一些？

* 1）call和apply是Function原型上的方法，每个Function的实例都可以调原型上的这两个方法；
* 2）这两个方法执行的目的都是改变函数中的this指向；
* 3）区别在于call的参数是一个一个传递的，而apply的参数是以数组形式传递的
> 相类似的还有方法bind， bind也是用来改变函数中的this指向，bind没有把函数立即执行，只是预先改变this

> 性能上，传三个以内参数差不多，三个以上时，call的性能更佳。
```
fn.call(obj, 10, 20, 30);
fn.apply(obj, [10, 20, 30]);
```

### 回调函数
> 回调函数中的this一般都是window

### 立即执行函数（IIFE） - 执行完后，立即销毁

> IIFE，原理实际是一个表达式的用法，类似+a; !a; -a;(a);

```
;(function() {});
~function() {}();
+function() {}();
!function() {}();
```

### 函数的作用域在函数创建的时候创建的

### 实名函数与匿名函数

* 实名函数：有函数名的
* 匿名函数：没有函数名的
*	1）函数表达式：把函数当做值赋值给变量或者元素的事件
		var fn = function() {};
		oBox.onclick = function() {};
*	2）自执行函数：创建和执行一起完成的
		~function() {}();
		+function() {}();
		!function() {}();

### 普通函数执行：
* 1）形成一个私有的作用域
* 2）形参赋值
* 3）变量提升
* 4）代码执行
* 5）栈内存释放问题

### 构造函数执行：

* 1）像普通函数执行一样，形成一个私有的作用域（栈内存）
	形参赋值；
	变量提升；
* 2）【构造函数独有的】在js代码自上而下执行之前，首先在当前形成的私有栈中创建一个对象（创建一个堆内存：暂时不存储任何东西）并且让函数中的执行主体（this）执行这个新的内存（this === 创建的对象）
* 3）代码自上而下执行
* 4）【构造函数独有】代码执行完成，把之前创建的堆内存地址返回（浏览器默认返回）

> 开始创建的对象其实就是当前这个类的实例，让this指向这个实例，代码执行中的this.x=y都是给实例设置私有属性，最后浏览器会默认把创建的实例返回，供外面接收。

> 再次执行new Fn，就是把上面的操作克隆一份，会形成新的实例（新的内存空间），所以说实例是独立分开的

