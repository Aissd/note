1、单例设计模式（singleton pattern）

```
1）变现形式：
var obj = {
	xxx: xxx,
	...
};
在单例设计模式中，obj不仅仅是对象名，它被称为“命名空间【NameSpace】”，把描述事物的属性存放到命名空间中，多个命名空间独立分开，互不冲突。
2）作用：把描述同一件事物的属性和特征进行分组，归类（存储在同一个堆内存空间中），因此避免了全局变量之间的污染。
```

2、高级单例模式

```
1）在给命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数，形成一个私有作用域AA（不销毁的栈内存），在AA中创建一个堆内存，把堆内存地址赋值给命名空间。
2）这种模式的好处：我们完全可以在AA中创造很多内容（变量or函数），哪些需要供外面调取使用的，就暴露到返回的对象中（模块化实现的一种思想）
var nameSpace = (function() {
	var n = 12;
	function fn() {
		// ...
	}
	return {
		fn: fn
	}
})();
```

3、this

```
1）给当前元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素对象；
2）普通函数执行，函数中的this取决于执行的主体，谁执行谁就是this（看方法名前面是否有点，没有this就是window）
```

4、工厂模式

```
1）把实现相同功能的代码进行“封装”，以此来实现“批量生产”（后期想要实现这个功能，只需执行函数即可）
2）“低耦合高内聚”：减少页面中的冗余代码，提高代码的重复使用率
```

5、面向对象编程

```
需要掌握：对象，类，实例
1）对象：万物皆对象
2）类：对象的具体细分
3）实例：类中具体的一个事物
```

6、创建类的两种方式以及区别

```
基于构造函数创建自定义类
1）在普通函数执行的基础上new X()，这样就不是普通函数执行了，而是构造函数执行，当前的函数名称之为“类名”，接收的返回结果是当前类的一个实例
2）自己创建的类名最好首字母大写
3）这种构造函数设计模式执行，主要用于组件，类库，插件，框架等封装，平时编写业务逻辑一般不这样处理
```

7、js中创建值有两种方式

```
1）字面量表达式
var obj = {};
2）构造函数模式
var obj = new Object();

以上两种方式创造出来的Object类的实例都是独立分开的


基本数据类型基于两种不同的模式创建出来的值是不一样的：

var num1 = 12; // 基本类型
var num2 = new Number(12); // 引用类型
console.log(typeof num1); // 'number'
console.log(typeof num2); // 'object'
```

8、构造函数执行

```
构造函数执行，不写return，浏览器会默认返回创建的实例。
但如果写了return，有以下结果：
1）如果return的是一个基本值，返回的结果依然是类的实例；
2）如果return的是一个引用值，会把默认的实例覆盖

function Fn() {
	var n = 10;
	this.m = n;
	// return n; // {m: 10} // => 还是原来的类实例
	// return; // {m: 10} // => 还是原来的类实例
	// return { name: '哈哈' }; // 实力被覆盖 => { name: '哈哈' }
}

var f = new Fn(); // new Fn; // 不传递实参时，可省略小括号
console.log(f);
```

9、面向对象 - oop

```
什么是面向对象？
	面向对象是一种编程思想，js本身就是基于面向对象构建出来的（例如：js中右很多内置类，像promise就是es6中新增的一个内置类，基于new Promise来创建一个实例管理异步编程）vue/react/jquery也是基于免息对象构建出来的，他们都是类，平时开发的时候都是基于创建他们的实例来操作的
	js中的面向对象，和其他编程语言还是有不同的，js中的类和实例是基于原型和原型链机制来处理的，而且js中关于类的重载，重写，继承也和其他语言不太一样
1）封装：低耦合高内聚
2）继承：
3）多态：重载和重写
	重载：方法名相同，形参个数或者类型不一样（js中不存在真正意义上的重载）
	重写：在类的继承中，子类可以重写父类中的方法
```

