### 浏览器渲染过程

![image-20201114145014529](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20201114145014529.png)

根据html结构生成DOM树
根据css生成CSSOM
将DOM和CSSOM整合形成RenderTree
根据RenderTree开始渲染和展示
遇到<script></script>时会执行并阻塞渲染



### 从用户在浏览器地址栏输入网址，到看到整个页面，中间都发生了哪些事情？
HTTP请求阶段

request请求阶段：

DNS解析，TCP协议的三次握手和四次挥手

HTTPS和HTTP的区别（HTTP2）

HTTP响应阶段

浏览器渲染阶段

### 浏览器向服务器发送请求，有哪些请求方式？

### 性能优化
1、减少HTTP请求

2、使用HTTP2（解析速度快，多路复用，首部压缩，优先级更高，流量控制，服务器推送）

3、使用服务端渲染

4、静态资源使用CDN（服务器离用户越远，延迟越高，使用CDN缩短请求时间）

5、将CSS放在文件头部，JavaScript文件放在底部（若要放头部，可加defer属性）

6、使用字体图标iconfont代替图片图标（将图标制作成字体，可以设置属性；文件较小；矢量图不会失真）

7、善用缓存，不重复加载相同的资源（添加Expires或max-age控制；在Expires设置的时间之前都不会请求文件，使用缓存；max-age是相对时间）

8、压缩文件

​	1）JavaScript：UglifyPlugin

​	2）CSS：MiniCssEtractPlugin

​	3）HTML：HtmlWebpackPlugin

​	4）gzip压缩：通过想HTTP请求头中的Accept-Encoding头添加gzip标识开启，服务器也得支持；

9、图片优化

​	1）图片延迟加载（在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片）

​	2）响应式图片（浏览器根据屏幕大小自动加载合适的图片）

​		2.1）通过picture实现

​		2.2）通过@media实现

​		2.3）通过调整图片大小（先加载缩略图，悬停或者点击放大再加载大图）

​		2.4）降低图片质量（jpg图片用ps压缩90%；背景图的话压缩到60%；image-webpack-loader压缩）

​		2.5）利用css3效果代替图片（渐变，阴影）

10、通过webpack按需加载代码，提取第三方库代码；减少es6转为es5的冗余代码（懒加载或按需加载）

11、减少重绘重排（回流）

​	当改变DOM元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排（回流）。

​	当重新生成渲染树后，就要改将渲染树每个节点绘制到屏幕，这个过程叫重绘。

​	重排一定会导致重绘，反之则不一定。

​	什么操作会导致重排：

​	1）添加或删除可见的DOM元素

​	2）元素位置改变

​	3）元素尺寸改变

​	4）内容改变

​	5）浏览器窗口尺寸改变

​	如何减少重排重绘

​	1）用js修改样式时，最好不要直接写样式，而是替换class来改变样式；

​	2）将DOM脱离文档流，修改完后再将它带回文档（使用隐藏元素display：none或文档碎片）

12、使用事件委托

13、注意程序的局部性（没懂）

14、使用switch代替if-else（两个条件值以上）

15、查找表（对象索引）

16、避免页面卡顿（不懂）

17、使用requestAnimationFrame来实现视觉变化

18、使用web workers（使用独立的工作线程，执行任务而不干扰用户界面）

19、使用位操作（不懂）

20、不要覆盖原生方法

21、降低css选择器的复杂性

​	1）浏览器读取选择器，遵循的原则是从选择器的右边到左边读取

​	2）css选择器优先级（越短越好；尽量使用高优先级的选择器；避免使用通配符）

22、使用flexbox而不是较早的布局模型

23、使用transformhe opacity属性来改变动画（不会触发重排和重绘）

24、合理使用规则，避免过渡优化


资源压缩合并

图片懒加载

音频视频走流文件

