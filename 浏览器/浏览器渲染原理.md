https://mp.weixin.qq.com/s/1-cYom7sfgLsKzJn5oX3IQ

![image-20201124181442661](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20201124181442661.png)

> 浏览器的内核是指支持浏览器运行的最核心的程序分两个部分：渲染引擎和js引擎。

> 渲染引擎在不同浏览器上各不相同：

* Firefox叫Gecko
* chrome和safari是基于webkit开发的

> 浏览器工作流程大体分三部分：

1、浏览器会解析三个东西：
* HTML,SVG,XHTML，解析这三种文件会产生一个DOM树【DOM Tree】
* 解析CSS会产生css规则树【CSS Rule Tree】
* js脚本，主要是通过DOM API和CSSOM API来操作DOM树和css规则树

2、浏览器引擎会通过DOM树和CSS规则树来构造渲染树【Rendering Tree】
* 渲染树并不等于DOM树，因为像header或者display:none的东西就不会放在渲染树中
* CSS规则树附加上渲染树上的每个Element【也就是DOM节点】，即Frame
* 计算每一个Frame的位置，这个过程叫重排/回流【layout/reflow】的过程

3、调用操作系统Native GUI的API绘制



> 构建DOM

浏览器会遵守一套步骤将HTML文件转换为DOM树，宏观上分为几个步骤：

** 字节数据 => 字符串 => Token => Node => DOM **

构建DOM的具体步骤：

1、浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们换成字符串。（网络中传输的内容其实都是0和1这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码）

2、将字符串转换成Token，例如<html><body>等。** Token中会标识出当前Token是开始标签或者是结束标签亦或是文本等信息 **

3、生成节点对象并构建DOM
构建DOM过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。注意：带有结束标签的Token不会创建节点对象。

```
<html>
<head>
    <title>Web page parsing</title>
</head>
<body>
    <div>
        <h1>Web page parsing</h1>
        <p>This is an example Web page.</p>
    </div>
</body>
</html>
```
上面这段HTML会解析成这样：

![img](https://mmbiz.qpic.cn/mmbiz/12mPmHVcSumHByKGu9h0IhaH5LdhxSe8BHdbHQjFP46ILa9PxwqXibbictia57lFXEMkvgyAIDBoAQ12icuibyFzGVA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)


> 构建CSSOM
当浏览器接收到一段css，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM



** 字节数据 => 字符串 => Token => Node => CSSOM **

浏览器会确定每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。这一过程中，浏览器得递归CSSOM树，然后确定具体的元素到底是什么样式。



** 注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。 **

>  构建渲染树

当生成DOM树和CSSOM树以后，需要将这两棵树组合为渲染树。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/12mPmHVcSumHByKGu9h0IhaH5LdhxSe8T09SbXwWQcrTgFm9Lwib0PmmkrP6WFkYqCr8urNETT4NBT4hTxPdcEQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这一过程，不是简单将两者合并就行了。渲染树只会包括需要显示的字节和这些节点的样式信息，如果某个节点是display:none的，那就不会再渲染树中显示。

> 布局与绘制

当浏览器生成渲染树以后，就会根据渲染树来进行重排【回流】。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。

重排【回流】过程的输出是一个盒模型，会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都会转换为屏幕上的绝对像素。

重排【回流】完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。

> 问题一：渲染过程遇到js文件怎么处理？

js的加载，解析与执行会阻塞DOM的构建。（即构建DOM时，HTML解析器遇到了js，那么他会暂停构建DOM，将控制权移交给js引擎，等js引擎运行完毕，浏览器再从中断的地方恢复DOM构建）

也就是说，若想首屏渲染得快，就越不应该在首屏就加载js文件，这也是都建议将script标签放在body标签底部的原因。（也可以给script标签添加defer或者async属性）

js不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。（原本DOM和CSSOM的构建互不影响，只有CSSOM构建完毕后，再恢复DOM构建）因为js不只是可以改DOM，也可以改样式。**浏览器会先下载和构建CSSOM，然后再执行js，最后再继续构建DOM**

> 问题二：你真的了解回流和重绘吗

![img](https://mmbiz.qpic.cn/mmbiz/12mPmHVcSumHByKGu9h0IhaH5LdhxSe8gCSGtuZLyOvuC2fSlub3rqT1593Zb76ub3ebPc7ic4v7qz9eiaTRBtBA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

当网页生成的时候，至少会渲染一次。
* 重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color
* 重排【回流】：当渲染树中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等而改变需要重新构建
**重排【回流】必定会发生重绘，重绘不一定会引发回流**